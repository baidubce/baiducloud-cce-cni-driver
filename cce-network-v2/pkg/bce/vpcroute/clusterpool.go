/*
 * Copyright (c) 2023 Baidu, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */
package vpcroute

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	operatorOption "github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/operator/option"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/bce/api/cloud"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/bce/option"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/cidr"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/controller"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/ip"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/ipam"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/ipam/allocator"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/ipam/allocator/clusterpool"
	ipamTypes "github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/ipam/types"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/k8s"
	ccev2 "github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/k8s/apis/cce.baidubce.com/v2"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/lock"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/logging"
	"github.com/baidubce/baiducloud-cce-cni-driver/cce-network-v2/pkg/logging/logfields"
	"github.com/baidubce/bce-sdk-go/services/vpc"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/wait"
)

const (
	routeSyncherTaskName = "vpcroute-syncher"
	// for vpc api
	nexthopType = "custom"
)

var (
	log              = logging.NewSubysLogger("vpcroute")
	routeDescription = "auto generated by cce"
)

type VPCRouteOperator struct {
	mutex     *lock.Mutex
	allocator *clusterpool.AllocatorOperator
	updater   ipam.NetResourceSetGetterUpdater
	// realHandler is the real handler to handle node event
	realHandler allocator.NodeEventHandler

	bceClient    cloud.Interface
	vpcRouteMap  map[string]*vpc.RouteRule
	routeTableID string
}

func (operator *VPCRouteOperator) Init(ctx context.Context) error {
	operator.allocator = &clusterpool.AllocatorOperator{}

	operator.bceClient = option.BCEClient()
	operator.mutex = &lock.Mutex{}
	operator.vpcRouteMap = make(map[string]*vpc.RouteRule)

	routeDescription = fmt.Sprintf("%s:%s", routeDescription, operatorOption.Config.CCEClusterID)
	return operator.allocator.Init(ctx)
}

func (operator *VPCRouteOperator) Start(ctx context.Context, updater ipam.NetResourceSetGetterUpdater) (allocator.NodeEventHandler, error) {
	operator.updater = updater

	manager := controller.NewManager()
	manager.UpdateController(routeSyncherTaskName, controller.ControllerParams{
		DoFunc:      operator.doSyncVPCRouteRules,
		RunInterval: operatorOption.Config.ResourceResyncInterval,
	})
	manager.TriggerController(routeSyncherTaskName)

	var err error
	operator.realHandler, err = operator.allocator.Start(ctx, updater)
	if err != nil {
		return nil, err
	}
	return operator, nil
}

func (operator *VPCRouteOperator) doSyncVPCRouteRules(ctx context.Context) error {
	rules, err := operator.bceClient.ListRouteTable(ctx, operatorOption.Config.BCECloudVPCID, "")
	if err != nil {
		log.WithError(err).Error("failed to list route table")
		return err
	}
	log.Debugf("list route table return length is %d", len(rules))

	tmpMap := make(map[string]*vpc.RouteRule)
	for i := range rules {
		rule := &rules[i]
		tmpMap[rule.NexthopId+rule.DestinationAddress] = rule
		if operator.routeTableID == "" {
			operator.mutex.Lock()
			operator.routeTableID = rule.RouteTableId
			operator.mutex.Unlock()
		}
	}
	operator.mutex.Lock()
	operator.vpcRouteMap = tmpMap
	operator.mutex.Unlock()
	return nil
}

// Create implements allocator.NodeEventHandler
func (operator *VPCRouteOperator) Create(resource *ccev2.NetResourceSet) error {
	return operator.realHandler.Create(resource)
}

// Delete implements allocator.NodeEventHandler
func (operator *VPCRouteOperator) Delete(nodeName string) error {
	oldNode, err := operator.updater.Get(nodeName)
	if err == nil && oldNode != nil {
		return operator.Update(oldNode)
	}
	return operator.realHandler.Delete(nodeName)
}

// Resync implements allocator.NodeEventHandler
func (operator *VPCRouteOperator) Resync(context.Context, time.Time) {
	operator.realHandler.Resync(context.Background(), time.Now())
}

// Update implements allocator.NodeEventHandler
func (operator *VPCRouteOperator) Update(resource *ccev2.NetResourceSet) error {
	if len(resource.Status.IPAM.VPCRouteCIDRs) == 0 {
		resource.Status.IPAM.VPCRouteCIDRs = make(ipamTypes.VPCRouteStatuMap)
	}
	var (
		newObj    = resource.DeepCopy()
		err       error
		scopedLog = log.WithFields(logrus.Fields{
			"node": resource.Name,
		})

		// updateFinalizer is used to indicate whether need to update "RemoteRouteFinalizer" finalizer
		updateFinalizer = false
	)

	scopedLog.Debug("start to update netresourceset")
	defer func() {
		if err != nil {
			scopedLog.WithError(err).WithField("method", "Update").Error("failed to update netresourceset")
			return
		}
		scopedLog.Debug("update netresourceset successfully")
	}()

	// add/remove finalizer
	if resource.DeletionTimestamp == nil {
		updateFinalizer = appendRemoteRouteFinalizerToNetResourceSet(newObj)
	} else if len(newObj.Status.IPAM.VPCRouteCIDRs) == 0 {
		updateFinalizer = removeRemoteRouteFinalizerFromNetResourceSet(newObj)
	}
	if updateFinalizer {
		_, err = operator.updater.Update(resource, newObj)
		if err != nil {
			scopedLog.WithError(err).WithField("method", "Update").Error("failed to update netresourceset")
			return err
		}
		scopedLog.Debug("add finalizer to netresourceset")
		return nil
	}

	// update the node until 30s timeout
	// if update operation return error, we will get the leatest version of node and try again
	err = wait.PollImmediate(200*time.Millisecond, 30*time.Second, func() (bool, error) {
		return operator.updateVPCRouteStatus(scopedLog, resource.Name)
	})
	if err != nil {
		scopedLog.WithError(err).Errorf("failed to update netresource %s", resource.Name)
		return err
	}

	resource, err = operator.updater.Get(resource.Name)
	if err != nil {
		return err
	}
	return operator.realHandler.Update(resource)
}

// updateVPCRouteStatus is used for updating netresourceset status when vpc route rule should be sync
// return true to indicate that the rule should be synced
// return false to indicate that the rule should not be synced
func (operator *VPCRouteOperator) updateVPCRouteStatus(scopedLog *logrus.Entry, name string) (bool, error) {
	resource, err := operator.updater.Get(name)
	if err != nil {
		return false, err
	}
	if len(resource.Status.IPAM.VPCRouteCIDRs) == 0 {
		resource.Status.IPAM.VPCRouteCIDRs = make(ipamTypes.VPCRouteStatuMap)
	}
	if operator.routeTableID == "" {
		err = operator.doSyncVPCRouteRules(context.TODO())
		if err != nil {
			return false, err
		}
	}
	if operator.routeTableID == "" {
		scopedLog.Warningf("failed to get route table for %s. retry later", name)
		return false, nil
	}
	var (
		ctx    = context.Background()
		newObj = resource.DeepCopy()
	)

	toAddCIDR, toDeleteCIDR := operator.determineNodeActions(newObj)

	// to clean all vpc route via this node, this is equivalent to clearing
	// all CIDR of the current node
	for _, rule := range toDeleteCIDR {
		err = operator.bceClient.DeleteRouteRule(ctx, rule.RouteRuleId)
		if err != nil {
			scopedLog.WithError(err).WithField("rule", logfields.Repr(rule)).Error("failed to delete vpc route rule")
			continue
		}
		operator.mutex.Lock()
		delete(operator.vpcRouteMap, rule.NexthopId+rule.DestinationAddress)
		operator.mutex.Unlock()
		scopedLog.WithField("rule", logfields.Repr(rule)).Info("delete vpc route rule success")
	}

	// we need to clean up the same target rule with different nexthop first
	// otherwise we will get error when creating the new rule
	for _, rule := range toAddCIDR {
		arg := &vpc.CreateRouteRuleArgs{
			RouteTableId:       rule.RouteTableId,
			SourceAddress:      rule.SourceAddress,
			DestinationAddress: rule.DestinationAddress,
			NexthopType:        rule.NexthopType,
			NexthopId:          rule.NexthopId,
			Description:        rule.Description,
		}
		ruleID, err := operator.bceClient.CreateRouteRule(ctx, arg)
		if err != nil {
			scopedLog.WithError(err).WithField("rule", logfields.Repr(rule)).Error("failed to create vpc route rule")
			continue
		}
		rule.RouteRuleId = ruleID
		operator.mutex.Lock()
		operator.vpcRouteMap[rule.NexthopId+rule.DestinationAddress] = rule
		operator.mutex.Unlock()
		scopedLog.WithField("rule", logfields.Repr(rule)).Info("create vpc route rule success")
	}

	// update status if route table already exists
	for _, cidr := range newObj.Spec.IPAM.PodCIDRs {
		operator.mutex.Lock()
		vpcRule := operator.vpcRouteMap[newObj.Spec.InstanceID+cidr]
		operator.mutex.Unlock()
		if vpcRule != nil {
			newObj.Status.IPAM.VPCRouteCIDRs[cidr] = ipamTypes.VPCRouteStatusInUse
		}
	}

	// clean vpc route status if route table already delete on VPC
	for target := range newObj.Status.IPAM.VPCRouteCIDRs {
		operator.mutex.Lock()
		vpcRule := operator.vpcRouteMap[newObj.Spec.InstanceID+target]
		operator.mutex.Unlock()

		if vpcRule == nil && len(operator.vpcRouteMap) != 0 &&
			newObj.Status.IPAM.VPCRouteCIDRs[target] != ipamTypes.VPCRouteStatusReleased {
			scopedLog.WithField("target", target).Info("released vpc route")
			newObj.Status.IPAM.VPCRouteCIDRs[target] = ipamTypes.VPCRouteStatusReleased
			if newObj.DeletionTimestamp != nil {
				delete(newObj.Status.IPAM.VPCRouteCIDRs, target)
				scopedLog.WithField("target", target).Info("delete vpc route status success")
			}
		}
	}

	if !reflect.DeepEqual(newObj.Status, resource.Status) {
		_, err = operator.updater.UpdateStatus(resource, newObj)
		if err != nil {
			scopedLog.WithError(err).WithField("method", "Update").Error("failed to update netresourceset status")
			return false, err
		}
		scopedLog.Debug("update status of netresourceset success")
	}
	return true, nil
}

// determineNodeActions returns the list of route rules to add and delete
func (operator *VPCRouteOperator) determineNodeActions(netResourceSet *ccev2.NetResourceSet) (toAddCIDR, toDeleteCIDR []*vpc.RouteRule) {
	operator.mutex.Lock()
	defer operator.mutex.Unlock()
	var (
		specCIDRs map[string]bool = make(map[string]bool)
		ccestatus                 = netResourceSet.Status.IPAM.VPCRouteCIDRs
	)
	if ccestatus == nil {
		ccestatus = make(ipamTypes.VPCRouteStatuMap)
	}

	if netResourceSet.DeletionTimestamp == nil {
		for _, cidr := range netResourceSet.Spec.IPAM.PodCIDRs {
			specCIDRs[cidr] = true
			if ccestatu, ok := ccestatus[cidr]; ok && ccestatu == ipamTypes.VPCRouteStatusInUse {
				continue
			}
			rule, err := cidrToVPCRouteRule(cidr, netResourceSet.Spec.InstanceID, operator.routeTableID)
			if err != nil {
				log.WithField("cidr", cidr).WithField("node", netResourceSet.Name).WithError(err).Error("failed to parse cidr")
				continue
			}
			if _, ok := operator.vpcRouteMap[rule.NexthopId+rule.DestinationAddress]; !ok {
				toAddCIDR = append(toAddCIDR, rule)
			}
		}

		// to delete route means cidr not in newStatusCIDR but in oldStatusCIDR
		for _, rule := range operator.vpcRouteMap {
			if !strings.Contains(rule.Description, routeDescription) {
				continue
			}
			if _, inCIDRs := specCIDRs[rule.DestinationAddress]; inCIDRs {
				if rule.NexthopId != netResourceSet.Spec.InstanceID {
					toDeleteCIDR = append(toDeleteCIDR, rule)
				}
				continue
			}
			// delete all route rules via this node which has been deleted from the spec
			if rule.NexthopId == netResourceSet.Spec.InstanceID {
				toDeleteCIDR = append(toDeleteCIDR, rule)
			}
		}
	} else {
		// delete all route rules via this node which created by this operator
		for _, rule := range operator.vpcRouteMap {
			if rule.NexthopId != netResourceSet.Spec.InstanceID {
				continue
			}
			if !strings.Contains(rule.Description, routeDescription) {
				continue
			}
			toDeleteCIDR = append(toDeleteCIDR, rule)
		}
	}
	return
}

var _ allocator.NodeEventHandler = &VPCRouteOperator{}

func cidrToVPCRouteRule(cidrkey, instanceID, routeTableID string) (*vpc.RouteRule, error) {
	cidrNet, err := cidr.ParseCIDR(cidrkey)
	if err != nil {
		return nil, err
	}
	var (
		sourceAddress = ip.IPv4ZeroCIDR.String()
	)
	if cidrNet.IP.To4() == nil {
		sourceAddress = ip.IPv6ZeroCIDR.String()
	}
	return &vpc.RouteRule{
		RouteTableId:       routeTableID,
		SourceAddress:      sourceAddress,
		DestinationAddress: cidrkey,
		NexthopId:          instanceID,
		NexthopType:        nexthopType,
		Description:        routeDescription,
	}, nil
}

// appendRemoteRouteFinalizerToNetResourceSet appends the finalizer for remote routes to the given CCE node if it is not already
// present.
func appendRemoteRouteFinalizerToNetResourceSet(netResourceSet *ccev2.NetResourceSet) bool {
	if !containsString(netResourceSet.Finalizers, k8s.FinalizerOfNetResourceSetRoute) {
		netResourceSet.Finalizers = append(netResourceSet.Finalizers, k8s.FinalizerOfNetResourceSetRoute)
		return true
	}
	return false
}

// removeRemoteRouteFinalizerFromNetResourceSet removes the finalizer for remote routes from the given CCE node if it is present.
func removeRemoteRouteFinalizerFromNetResourceSet(netResourceSet *ccev2.NetResourceSet) bool {
	if containsString(netResourceSet.Finalizers, k8s.FinalizerOfNetResourceSetRoute) {
		netResourceSet.Finalizers = removeString(netResourceSet.Finalizers, k8s.FinalizerOfNetResourceSetRoute)
		return true
	}
	return false
}

// containsString returns true if the given string is in the given slice.
func containsString(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}
	return false
}

// removeString removes the given string from the given slice.
func removeString(slice []string, s string) []string {
	var result []string
	for _, item := range slice {
		if item != s {
			result = append(result, item)
		}
	}
	return result
}
